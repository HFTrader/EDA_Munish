/***************************************************************************//**
 *   @file   main.c

*******************************************************************************/

/******************************************************************************/
/***************************** Include Files **********************************/
/******************************************************************************/
#include <stdio.h>
#include "xil_cache.h"
#include "xbasic_types.h"
#include "xil_io.h"
#include "cf_hdmi.h"
#include "atv_platform.h"
#include "transmitter.h"
#include "xil_exception.h"
#include "xuartps.h"
// for interrupt handling
#include "axi_interrupt.h"
#include "xscugic.h"
#include "xil_mmu.h"
#include "sw_functions.h"
#include "xpseudo_asm.h"
#include "global.h"
//#include "xgray_scale.h"
#include "hw_config.h"
#include "profile_cnt.h"



/******************************************************************************/
/************************ Variables Definitions *******************************/
/******************************************************************************/
static UCHAR    MajorRev;      /* Major Release Number */
static UCHAR    MinorRev;      /* Usually used for code-drops */
static UCHAR    RcRev;         /* Release Candidate Number */
static BOOL     DriverEnable;
static BOOL     LastEnable;


XScuGic InterruptController; /* Instance of the Interrupt Controller */
static XScuGic_Config *GicConfig;/* The configuration parameters of the controller */


short int FRAME_INTR = 0;

XGray_scale xGrayScaleFilter1, xGrayScaleFilter2;



int ScuGicInterrupt_Init()
{
	int Status;
	/*
	 * Initialize the interrupt controller driver so that it is ready to
	 * use.
	 * */
	Xil_ExceptionInit();

	GicConfig = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);
	if (NULL == GicConfig) {
		return XST_FAILURE;
	}

	Status = XScuGic_CfgInitialize(&InterruptController, GicConfig,
			GicConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	 // **** Setup the Interrupt System *****

//	 * Connect the interrupt controller interrupt handler to the hardware
//	 * interrupt handling logic in the ARM processor.
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT,
			(Xil_ExceptionHandler) XScuGic_InterruptHandler,
			(void *) &InterruptController);

//	 * Connect a device driver handler that will be called when an
//	 * interrupt for the device occurs, the device driver handler performs
//	 * the specific interrupt processing for the device
	Status = XScuGic_Connect(&InterruptController,XPAR_FABRIC_CAM_INTERFACE_0_VSYNC_NEGEDGE_INTR,
			(Xil_ExceptionHandler)AXI_INTERRUPT_VsyncIntr_Handler,
			(void *) &InterruptController);
	XScuGic_Enable(&InterruptController, XPAR_FABRIC_CAM_INTERFACE_0_VSYNC_NEGEDGE_INTR);

// 	Enable interrupts in the ARM
	Xil_ExceptionEnable();

	//Only used for edge sensitive Interrupts
	XScuGic_SetPriorityTriggerType(&InterruptController, XPAR_FABRIC_CAM_INTERFACE_0_VSYNC_NEGEDGE_INTR, 0xa0, 3);

	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}
	return XST_SUCCESS ; 
}

void delay_us(u32 us_count) {
  u32 count;
  for (count = 0; count < ((us_count * 800) + 1); count++) {
    asm("nop");
  }
}

/***************************************************************************//**
 * @brief Enables the driver.
 *
 * @return Returns ATVERR_OK.
*******************************************************************************/
void APP_EnableDriver (BOOL Enable)
{
    DriverEnable = Enable;
}

/***************************************************************************//**
 * @brief Returns the driver enable status.
 *
 * @return Returns the driver enable status.
*******************************************************************************/
static BOOL APP_DriverEnabled (void)
{
    if ((DriverEnable && HAL_GetMBSwitchState()) != LastEnable)
    {
        LastEnable = DriverEnable && HAL_GetMBSwitchState();
        DBG_MSG ("APP: Driver %s\n\r", LastEnable? "Enabled": "Disabled");
    }
    return (LastEnable);
}


void configureGrayscaleFilter() {
	xGrayScaleFilter1.Control_bus_BaseAddress = XPAR_GRAY_SCALE_TOP_0_S_AXI_CONTROL_BUS_BASEADDR;
	xGrayScaleFilter1.IsReady = XIL_COMPONENT_IS_READY;
	config_grayScaleFilter(xGrayScaleFilter1);
	resetVDMA(1);
	config_filterVDMA(XPAR_AXI_VDMA_1_BASEADDR, DMA_MEM_TO_DEV, VIDEO_BASEADDR);
	config_filterVDMA(XPAR_AXI_VDMA_1_BASEADDR, DMA_DEV_TO_MEM, HWPROC_VIDEO_BASEADDR);
}


/***************************************************************************//**
 * @brief Changes the video resolution depending on User input.
 *
 * @return None.
*******************************************************************************/
static int APP_ChangeResolution (void)
{
	char *resolutions[7] = {"640x480", "800x600", "1024x768", "1280x720", "1360x768", "1600x900", "1920x1080"};
	char receivedChar    = 0;

	if(XUartPs_IsReceiveData(UART_BASEADDR))
	{
		receivedChar = inbyte();
		if((receivedChar >= 0x30) && (receivedChar <= 0x36))
		{
			SetVideoResolution(receivedChar - 0x30);
			DBG_MSG("Resolution was changed to %s \r\n", resolutions[receivedChar - 0x30]);
		}
		else if (receivedChar == 'q') {
			DBG_MSG("Exiting Application. \n\r");
		    return(0);
		    }
		else
		{
			if((receivedChar != 0x0A) && (receivedChar != 0x0D))
			{
				SetVideoResolution(RESOLUTION_640x480);
				DBG_MSG("Resolution was changed to %s \r\n", resolutions[0]);
			}
		}

		configureGrayscaleFilter();
	}
	return 1;
}


// this function when called, leaves current core's frame and starts processing the other core's video frame!!
void GrayscaleFilter_processVideoFrame() {
	static unsigned char flag = 0;
	flag++;
	if (flag == 1) {
		config_filterVDMA(XPAR_AXI_VDMA_1_BASEADDR, DMA_MEM_TO_DEV, VIDEO_BASEADDR_CPU1);
	} else if (flag == 2) {
		config_filterVDMA(XPAR_AXI_VDMA_1_BASEADDR, DMA_MEM_TO_DEV, VIDEO_BASEADDR);
		flag = 0;
	}

}


void CPU1_init() {

	// duplicating the initial boot code for CPU1 into ddr and then jumping to that boot code!
	Xil_Out32((u32) 0x06000000, (u32) 0xe3e0000f);
	Xil_Out32((u32) 0x06000004, (u32) 0xe3a01000);
	Xil_Out32((u32) 0x06000008, (u32) 0xe5801000);
	Xil_Out32((u32) 0x0600000c, (u32) 0xe320f002);
	Xil_Out32((u32) 0x06000010, (u32) 0xe5902000);
	Xil_Out32((u32) 0x06000014, (u32) 0xe1520001);
	Xil_Out32((u32) 0x06000018, (u32) 0x0afffffb);
	Xil_Out32((u32) 0x0600001c, (u32) 0xe1a0f002);


    // BSP startup code!!

	asm volatile ("mrc     p15, 0, r0, c0, c0, 0		/* Get the revision */\n"
					"and     r5, r0, #0x00f00000\n"
					"and     r6, r0, #0x0000000f\n"
					"orr     r6, r6, r5, lsr #20-4\n"
					"#ifdef CONFIG_ARM_ERRATA_742230/n"
							"cmp     r6, #0x22                       /* only present up to r2p2 */\n"
							"mrcle   p15, 0, r10, c15, c0, 1         /* read diagnostic register */\n"
							"orrle   r10, r10, #1 << 4               /* set bit #4 */\n"
							"mcrle   p15, 0, r10, c15, c0, 1         /* write diagnostic register */\n"
					"#endif\n"

					"#ifdef CONFIG_ARM_ERRATA_743622\n"
						"teq     r5, #0x00200000                 /* only present in r2p* */\n"
						"mrceq   p15, 0, r10, c15, c0, 1         /* read diagnostic register */\n"
						"orreq   r10, r10, #1 << 6               /* set bit #6 */\n"
						"mcreq   p15, 0, r10, c15, c0, 1         /* write diagnostic register */\n"
					"#endif\n"

					"/* set VBAR to the _vector_table address in linker script */\n"
					"ldr	r0, =_vector_table\n"
					"mcr	p15, 0, r0, c12, c0, 0\n"

					"/*set scu enable bit in scu*/\n"
					"ldr	r7, =0xf8f00000\n"
					"ldr	r0, [r7]\n"
					"orr	r0, r0, #0x1\n"
					"str	r0, [r7]\n"

					"/*invalidate scu*/\n"
					"ldr	r7, =0xf8f0000c\n"
					"ldr	r6, =0xffff\n"
					"str	r6, [r7]\n"

					"/* Write to ACTLR */\n"
					"mrc	p15, 0, r0, c1, c0, 1		/* Read ACTLR*/\n"
					"orr	r0, r0, #(0x01 << 6)		/* set SMP bit */\n"
					"orr	r0, r0, #(0x01 )		/* */\n"
					"mcr	p15, 0, r0, c1, c0, 1		/* Write ACTLR*/\n"

					"/* Invalidate caches and TLBs */\n"
					"mov	r0,#0				/* r0 = 0  */\n"
					"mcr	p15, 0, r0, c8, c7, 0		/* invalidate TLBs */\n"
					"mcr	p15, 0, r0, c7, c5, 0		/* invalidate icache */\n"
					"mcr	p15, 0, r0, c7, c5, 6		/* Invalidate branch predictor array */\n"
					"bl	invalidate_dcache		/* invalidate dcache */\n"


					"/* Disable MMU, if enabled */\n"
					"mrc	p15, 0, r0, c1, c0, 0		/* read CP15 register 1 */\n"
					"bic	r0, r0, #0x1			/* clear bit 0 */\n"
					"mcr	p15, 0, r0, c1, c0, 0		/* write value back */\n"



					"mrs	r0, cpsr			/* get the current PSR */\n"
					"mvn	r1, #0x1f			/* set up the irq stack pointer */\n"
					"and	r2, r1, r0\n"
					"orr	r2, r2, #0x12			/* IRQ mode */\n"
					"msr	cpsr, r2\n"
					"ldr	r13,=__irq_stack			/* IRQ stack pointer */\n"

					"mrs	r0, cpsr			/* get the current PSR */\n"
					"mvn	r1, #0x1f			/* set up the supervisor stack pointer */\n"
					"and	r2, r1, r0\n"
					"orr	r2, r2, #0x13			/* supervisor mode */\n"
					"msr	cpsr, r2\n"
					"ldr	r13,=__supervisor_stack			/* Supervisor stack pointer */\n"

					"mrs	r0, cpsr			/* get the current PSR */\n"
					"mvn	r1, #0x1f			/* set up the Abort  stack pointer */\n"
					"and	r2, r1, r0\n"
					"orr	r2, r2, #0x17			/* Abort mode */\n"
					"msr	cpsr, r2\n"
					"ldr	r13,=__abort_stack		/* Abort stack pointer */\n"

					"mrs	r0, cpsr			/* get the current PSR */\n"
					"mvn	r1, #0x1f			/* set up the FIQ stack pointer */\n"
					"and	r2, r1, r0\n"
					"orr	r2, r2, #0x11			/* FIQ mode */\n"
					"msr	cpsr, r2\n"
					"ldr	r13,=__fiq_stack			/* FIQ stack pointer */\n"

					"mrs	r0, cpsr			/* get the current PSR */\n"
					"mvn	r1, #0x1f			/* set up the Undefine stack pointer */\n"
					"and	r2, r1, r0\n"
					"orr	r2, r2, #0x1b			/* Undefine mode */\n"
					"msr	cpsr, r2\n"
					"ldr	r13,=__undef_stack		/* Undefine stack pointer */\n"

					"mrs	r0, cpsr			/* get the current PSR */\n"
					"mvn	r1, #0x1f			/* set up the system stack pointer */\n"
					"and	r2, r1, r0\n"
					"orr	r2, r2, #0x1F			/* SYS mode */\n"
					"msr	cpsr, r2\n"
					"ldr	r13,=__stack			/* SYS stack pointer */\n"

					"/* enable MMU and cache */\n"

					"ldr	r0,=MMUTable			/* Load MMU translation table base */\n"
					"orr	r0, r0, #0x5B			/* Outer-cacheable, WB */\n"
					"mcr	15, 0, r0, c2, c0, 0		/* TTB0 */\n"


					"mvn	r0,#0				/* Load MMU domains -- all ones=manager */\n"
					"mcr	p15,0,r0,c3,c0,0\n"

					"/* Enable mmu, icahce and dcache */\n"
					"ldr	r0,=0b00000000000000\n"

					"mcr	p15,0,r0,c1,c0,0		/* Enable cache and MMU */\n"
					"dsb					/* dsb	allow the MMU to start up */\n"

					"isb					/* isb	flush prefetch buffer */\n"



					"mov	r0, r0\n"
					"mrc	p15, 0, r1, c1, c0, 2		/* read cp access control register (CACR) into r1 */\n"
					"orr	r1, r1, #(0xf << 20)		/* enable full access for p10 & p11 */\n"
					"mcr	p15, 0, r1, c1, c0, 2		/* write back into CACR */\n"

					"/* enable vfp */\n"
					"fmrx	r1, FPEXC			/* read the exception register */\n"
					"orr	r1,r1, #0x40000000		/* set VFP enable bit, leave the others in orig state */\n"
					"fmxr	FPEXC, r1			/* write back the exception register */\n"

					"mrc	p15,0,r0,c1,c0,0		/* flow prediction enable */\n"
					"orr	r0, r0, #(0x01 << 11)		/* #0x8000 */\n"
					"mcr	p15,0,r0,c1,c0,0\n"

					"mrc	p15,0,r0,c1,c0,1		/* read Auxiliary Control Register */\n"
					"orr	r0, r0, #(0x1 << 2)		/* enable Dside prefetch */\n"
					"orr	r0, r0, #(0x1 << 1)		/* enable L2 Prefetch hint */\n"
					"mcr	p15,0,r0,c1,c0,1		/* write Auxiliary Control Register */\n"





					"/* Clear cp15 regs with unknown reset values */\n"
					"mov	r0, #0x0\n"
					"mcr	p15, 0, r0, c5, c0, 0	/* DFSR */\n"
					"mcr	p15, 0, r0, c5, c0, 1	/* IFSR */\n"
					"mcr	p15, 0, r0, c6, c0, 0	/* DFAR */\n"
					"mcr	p15, 0, r0, c6, c0, 2	/* IFAR */\n"
					"mcr	p15, 0, r0, c9, c13, 2	/* PMXEVCNTR */\n"
					"mcr	p15, 0, r0, c13, c0, 2	/* TPIDRURW */\n"
					"mcr	p15, 0, r0, c13, c0, 3	/* TPIDRURO */\n"
					"mcr	p15, 5, r0, c15, c5, 2	/* Write Lockdown TLB VA */\n"

					"/* Reset and start Cycle Counter */\n"
					"mov	r2, #0x80000000		/* clear overflow */\n"
					"mcr	p15, 0, r2, c9, c12, 3\n"
					"mov	r2, #0xd		/* D, C, E */\n"
					"mcr	p15, 0, r2, c9, c12, 0\n"
					"mov	r2, #0x80000000		/* enable cycle counter */\n"
					"mcr	p15, 0, r2, c9, c12, 1\n"


					".Lsbss_start:\n"
					"	.long	__sbss_start\n"

					".Lsbss_end:\n"
					"	.long	__sbss_end\n"

					".Lbss_start:\n"
					"	.long	__bss_start\n"

					".Lbss_end:\n"
					"	.long	__bss_end\n"
					".Lstack:\n"
					"	.long	__stack\n"




					"mov	r0, #0\n"

					"/* clear sbss */\n"
					"ldr 	r1,.Lsbss_start		/* calculate beginning of the SBSS */\n"
					"ldr	r2,.Lsbss_end		/* calculate end of the SBSS */\n"

					".Lloop_sbss:\n"
					"	cmp	r1,r2\n"
					"	bge	.Lenclsbss		/* If no SBSS, no clearing required */\n"
					"	str	r0, [r1], #4\n"
					"	b	.Lloop_sbss\n"

					".Lenclsbss:\n"
					"	/* clear bss */\n"
					"	ldr	r1,.Lbss_start		/* calculate beginning of the BSS */\n"
					"	ldr	r2,.Lbss_end		/* calculate end of the BSS */\n"
#if 0
					".Lloop_bss:\n"
					"	cmp	r1,r2\n"
					"	bge	.Lenclbss		/* If no BSS, no clearing required */\n"
					"	str	r0, [r1], #4\n"
					"	b	.Lloop_bss\n"

					".Lenclbss:\n"

					"	/* set stack pointer */\n"
					"	ldr	r13,.Lstack		/* stack address */\n"
#endif
					"	/* Reset and start Global Timer */\n"
					"	mov	r0, #0x0\n"
					"	mov	r1, #0x0\n"
					"	bl XTime_SetTime\n"


					"   /* run global constructors */\n"
					"   bl __libc_init_array\n"

					"	/* make sure argc and argv are valid */\n"
					"	mov	r0, #0\n"
					"	mov	r1, #0\n"

					"	/* Let her rip */\n"
					"mov r3, #0x0010266c\n"
					"bx r3\n"




					"invalidate_dcache:\n"
					"	mrc	p15, 1, r0, c0, c0, 1		/* read CLIDR */\n"
					"	ands	r3, r0, #0x7000000\n"
					"	mov	r3, r3, lsr #23			/* cache level value (naturally aligned) */\n"
					"	beq	finished\n"
					"	mov	r10, #0				/* start with level 0 */\n"
					"loop1:\n"
					"	add	r2, r10, r10, lsr #1		/* work out 3xcachelevel */\n"
					"	mov	r1, r0, lsr r2			/* bottom 3 bits are the Cache type for this level */\n"
					"	and	r1, r1, #7			/* get those 3 bits alone */\n"
					"	cmp	r1, #2\n"
					"	blt	skip				/* no cache or only instruction cache at this level */\n"
					"	mcr	p15, 2, r10, c0, c0, 0		/* write the Cache Size selection register */\n"
					"	isb					/* isb to sync the change to the CacheSizeID reg */\n"
					"	mrc	p15, 1, r1, c0, c0, 0		/* reads current Cache Size ID register */\n"
					"	and	r2, r1, #7			/* extract the line length field */\n"
					"	add	r2, r2, #4			/* add 4 for the line length offset (log2 16 bytes) */\n"
					"	ldr	r4, =0x3ff\n"
					"	ands	r4, r4, r1, lsr #3		/* r4 is the max number on the way size (right aligned) */\n"
					"	clz	r5, r4				/* r5 is the bit position of the way size increment */\n"
					"	ldr	r7, =0x7fff\n"
					"	ands	r7, r7, r1, lsr #13		/* r7 is the max number of the index size (right aligned) */\n"
					"loop2:\n"
					"	mov	r9, r4				/* r9 working copy of the max way size (right aligned) */\n"
					"loop3:\n"
					"	orr	r11, r10, r9, lsl r5		/* factor in the way number and cache number into r11 */\n"
					"	orr	r11, r11, r7, lsl r2		/* factor in the index number */\n"
					"	mcr	p15, 0, r11, c7, c14, 2		/* clean & invalidate by set/way */\n"
					"	subs	r9, r9, #1			/* decrement the way number */\n"
					"	bge	loop3\n"
					"	subs	r7, r7, #1			/* decrement the index */\n"
					"	bge	loop2\n"
					"skip:\n"
					"	add	r10, r10, #2			/* increment the cache number */\n"
					"	cmp	r3, r10\n"
					"	bgt	loop1\n"
					"finished:\n"
						"mov	r10, #0				/* swith back to cache level 0 */\n"
						"mcr	p15, 2, r10, c0, c0, 0		/* select current cache level in cssr */\n"
						"dsb\n"
						"isb\n"

						"bx	lr\n");


}

void test_CPU1() {
	Xil_SetTlbAttributes(SHARED_OCM_MEMORY_BASE, 0x14de2);

	Xil_ICacheEnable();
	Xil_DCacheEnable();

	asm volatile ("bx %0" : : "r" (0x06000000));
}


/***************************************************************************//**
 * @brief Main function.
 *
 * @return Returns 0.
*******************************************************************************/
int main()
{
/*	// check if CPU1 is executing this code.....if it is then move to 0x06000000 for its initial parking code
	u32 reg_val;
	asm volatile ("mrc p15,0,%0,c0,c0,5\n" : "=r" (reg_val));
	if (reg_val == 0x80000001) {
		asm volatile ("bx %0" : : "r" (0x06000000));
	}




	// elsif continue normal execution for CPU0*/


	UINT32 StartCount;
	int xstatus;
	MajorRev     = 1;
	MinorRev     = 1;
	RcRev        = 1;
	DriverEnable = TRUE;
	LastEnable   = FALSE;
	void (*funcPtr_CPU1init)() = CPU1_init;
	int delay;


    /* Disable caching on shared OCM data by setting the appropriate TLB
     * attributes for the shared data space in OCM.
	 *
     * S=b1
     * TEX=b100
     * AP=b11
     * Domain=b1111
     * C=b0
     * B=b0
	 */
    Xil_SetTlbAttributes(SHARED_OCM_MEMORY_BASE, 0x14de2);



#if 0
    if (Xil_In32((u32) 0xffff0000) != 0xa0a0a0a0)
    	Xil_Out32((u32) 0xffff0000, (u32) 0x50505050);




	if (Xil_In32((u32) 0xffff0000) == 0x50505050) {
		// initializing cpu1
		Xil_Out32(0xfffffff0, (u32) funcPtr_CPU1init);
		dmb(); // Wait until memory write has finished.
		sev();
		for (delay=0; delay<100000; delay++);			//sufficient delay to ensure cpu1 has been initialized!! better way could be use semaphore for inter cpu communuication*/

		Xil_Out32((u32) 0xffff0000, (u32) 0xa0a0a0a0);
		// going back to execute the startup code
		asm volatile ("bx %0" : : "r" (0x00100000));
	}
#endif


	Xil_Out32(0xfffffff0, (u32) funcPtr_CPU1init);
	dmb();
	sev();
	for (delay=0; delay<100000; delay++);


	EnablePerfCounters();
	init_perfcounters(1, 0);



	Xil_ICacheEnable();
	Xil_DCacheEnable();

	HAL_PlatformInit(XPAR_AXI_IIC_0_BASEADDR,	/* Perform any required platform init */
					 XPAR_SCUTIMER_DEVICE_ID,	/* including hardware reset to HDMI devices */
					 XPAR_SCUGIC_SINGLE_DEVICE_ID,
					 XPAR_SCUTIMER_INTR);

	/*xGrayScaleFilter1.Control_bus_BaseAddress = XPAR_GRAY_SCALE_TOP_0_S_AXI_CONTROL_BUS_BASEADDR;
	xGrayScaleFilter1.IsReady = XIL_COMPONENT_IS_READY;
	config_grayScaleFilter(xGrayScaleFilter1);
	resetVDMA(1);
	config_filterVDMA(XPAR_AXI_VDMA_1_BASEADDR, DMA_MEM_TO_DEV, VIDEO_BASEADDR);
	config_filterVDMA(XPAR_AXI_VDMA_1_BASEADDR, DMA_DEV_TO_MEM, HWPROC_VIDEO_BASEADDR);

	xGrayScaleFilter2.Control_bus_BaseAddress = XPAR_GRAY_SCALE_TOP_1_S_AXI_CONTROL_BUS_BASEADDR;
	xGrayScaleFilter2.IsReady = XIL_COMPONENT_IS_READY;
	config_grayScaleFilter(xGrayScaleFilter2);
	resetVDMA(2);
	config_filterVDMA(XPAR_AXI_VDMA_2_BASEADDR, DMA_MEM_TO_DEV, VIDEO_BASEADDR_CPU1);
	config_filterVDMA(XPAR_AXI_VDMA_2_BASEADDR, DMA_DEV_TO_MEM, HWPROC_VIDEO_BASEADDR);*/

	configureGrayscaleFilter();



	DBG_MSG("  To change the video resolution press:\r\n");
	DBG_MSG("  '0' - 640x480;  '1' - 800x600;  '2' - 1024x768; '3' - 1280x720 \r\n");
	DBG_MSG("  '4' - 1360x768; '5' - 1600x900; '6' - 1920x1080.\r\n");

	ADIAPI_TransmitterInit();   /* Initialize ADI repeater software and h/w */
	ADIAPI_TransmitterSetPowerMode(REP_POWER_UP);

	StartCount = HAL_GetCurrentMsCount();
	ADIAPI_TransmitterMain();
	
	/*Initialize the HDMI Core with default display settings*/
	SetVideoResolution(RESOLUTION_640x480);


	//ConfigHdmiVDMA(detailedTiming[currentResolution][H_ACTIVE_TIME], detailedTiming[currentResolution][V_ACTIVE_TIME], HWPROC_VIDEO_BASEADDR);
	ConfigHdmiVDMA(detailedTiming[currentResolution][H_ACTIVE_TIME], detailedTiming[currentResolution][V_ACTIVE_TIME], VIDEO_BASEADDR_CPU1);

	if (ATV_GetElapsedMs (StartCount, NULL) >= HDMI_CALL_INTERVAL_MS)
	{
		StartCount = HAL_GetCurrentMsCount();
		if (APP_DriverEnabled())
		{
			ADIAPI_TransmitterMain();
		}
	}


	/* Initialize the interrupt controller */
	xstatus = ScuGicInterrupt_Init();
	if (xstatus != XST_SUCCESS) {
		xil_printf("Unable to initialize Interrupts");
	  		//return XST_FAILURE;
	  	}


	while (APP_ChangeResolution())
	{
		if (ATV_GetElapsedMs (StartCount, NULL) >= HDMI_CALL_INTERVAL_MS)
		{
			StartCount = HAL_GetCurrentMsCount();
			if (APP_DriverEnabled())
			{
				ADIAPI_TransmitterMain();
			}
		}

		while (FRAME_INTR == 0);

		DDRVideoWr(640, 480, detailedTiming[currentResolution][H_ACTIVE_TIME], detailedTiming[currentResolution][V_ACTIVE_TIME], VIDEO_BASEADDR);
		FRAME_INTR = 0;
	}

	Xil_DCacheDisable();
	Xil_ICacheDisable();

	return(0);
}



// ISSUES:
// 1) own startup code cpu1
// 2) different resolution modes on cpu1 DDRVideoWr()







