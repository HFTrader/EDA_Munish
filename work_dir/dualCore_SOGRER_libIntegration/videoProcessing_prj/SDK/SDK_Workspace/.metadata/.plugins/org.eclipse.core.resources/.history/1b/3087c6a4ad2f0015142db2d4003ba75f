// NOTE: this would later be generated by the template engine using information from "SoC_config.h", "sw_functions.h"
// NOTE: right now simulating the scenario when there is a dual core ARM Cortex A9 on Zynq-PS and a Xilinx Microblaze core on Zynq-PL are available then the template engine would generate the following file

#ifndef SOCPROC_SUPPORT_H_
#define SOCPROC_SUPPORT_H_

// NOTE: if ZYNQ-ARM CortexA9 core is present in SoC
#include "ZYNQ_ARM_CORTEX_A9_support.h"
// NOTE: if Xilinx Microblaze 8.5 IP core is present in SoC
#include "XIL_MICROBLAZE_8_5_support.h"
// NOTE: and so on for other processors in "SoC_config.h"

// NOTE; if ZYNQ-ARM CortexA9 core is present in SoC
#define ZYNQ_ARM_CORTEX_A9 0
// NOTE: if Xilinx Microblaze 8.5 IP core is present in SoC
#define XIL_MICROBLAZE_8_5 1
// NOTE: and so on for other processors in "SoC_config.h"

// NOTE: get total number of Processors in SoC from "SoC_config.h"
#define NUM_PROCS 2

typedef struct {
	unsigned char m_type;
	unsigned char m_id;
	unsigned char m_busy;
	unsigned int m_MEM_BASEADDR;
} SoCProc;

SoCProc *SoCProc_elements;

// API for application developer
// NOTE: the signature for function pointer in _initialize function argument should be got from "sw_functions.h" where the app developer should provide function signature for main data processing chain method
void SoCProc_initialize();
// NOTE: create callback function pointer from "sw_functions.h"
unsigned char SoCProc_processDataflow();


#endif


// all the code in this module shall be executed by Master CPU only!!
