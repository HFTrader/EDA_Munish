// this driver corresponds to VDMA IP
// it is generated by modifying the auto-generated template



#ifndef __VDMAIP_DRIVER_TEMPLATE_H__
#define __VDMAIP_DRIVER_TEMPLATE_H__

#define bool unsigned char


typedef struct {
    unsigned int baseaddr;
} VDMAIPDriverInstance;


typedef struct {
    unsigned int offset;
    unsigned int value;
    unsigned int mask;
} VDMAIPRegType;




// register map for VDMA IP registers
typedef struct {
    // actual Xilinx AXI-VDMA IP has ~55 registers.....for now only a sample of registers are shown to provide an idea
    // only registers important for IP use are shown here...but in actual auto-generated file, all the registers will be present    
	VDMAIPRegType MM2S_DMACR;
    //      ...     //  NOTE: not shown here for simplicity
	VDMAIPRegType S2MM_DMACR;
	VDMAIPRegType S2MM_DMASR;
    //      ...     //  NOTE: not shown here for simplicity
	VDMAIPRegType MM2S_VSIZE;
	VDMAIPRegType MM2S_HSIZE;
	VDMAIPRegType MM2S_FRMDLY_STRIDE;
	VDMAIPRegType MM2S_START_ADDRESS1;
	VDMAIPRegType MM2S_START_ADDRESS2;
	VDMAIPRegType MM2S_START_ADDRESS3;
    //      ...     //  NOTE: not shown here for simplicity
	VDMAIPRegType S2MM_VSIZE;
	VDMAIPRegType S2MM_HSIZE;
	VDMAIPRegType S2MM_FRMDLY_STRIDE;
	VDMAIPRegType S2MM_START_ADDRESS1;
	VDMAIPRegType S2MM_START_ADDRESS2;
	VDMAIPRegType S2MM_START_ADDRESS3;
    //      ...     //  NOTE: not shown here for simplicity
} VDMAIPRegMap;


static void VDMAIP_Driver_localWriteReg(unsigned int addr, unsigned int mask, unsigned int value);
static unsigned int VDMAIP_Driver_localReadReg(unsigned int addr);
static void VDMAIP_Driver_SetHAMode(VDMAIPRegMap mode, unsigned int baseaddr);


// TODO: don't know how to initialize it properly...just resetting the vdma by seeing application code from Benjamin and hoping its in initialized state at startup
VDMAIPRegMap VDMAIPInitMode = {
		.MM2S_DMACR = {.offset = 0x00, .mask = 0x00000004, .value = 0x00000004},
		//      ...     //  NOTE: not shown here for simplicity
		.S2MM_DMACR = {.offset = 0x30, .mask = 0x00000004, .value = 0x00000004},
		.S2MM_DMASR = {.offset = 0x34, .mask = 0x00000000, .value = 0xffffffff},
		//      ...     //  NOTE: not shown here for simplicity
		.MM2S_VSIZE = {.offset = 0x50, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_HSIZE = {.offset = 0x54, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_FRMDLY_STRIDE  = {.offset = 0x58, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_START_ADDRESS1 = {.offset = 0x5c, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_START_ADDRESS2 = {.offset = 0x60, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_START_ADDRESS3 = {.offset = 0x64, .mask = 0x00000000, .value = 0xffffffff},
		//      ...     //  NOTE: not shown here for simplicity
		.S2MM_VSIZE = {.offset = 0xa0, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_HSIZE = {.offset = 0xa4, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_FRMDLY_STRIDE  = {.offset = 0xa8, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_START_ADDRESS1 = {.offset = 0xac, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_START_ADDRESS2 = {.offset = 0xb0, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_START_ADDRESS3 = {.offset = 0xb4, .mask = 0x00000000, .value = 0xffffffff}
		//      ...     //  NOTE: not shown here for simplicity
};


VDMAIPRegMap VDMAIPStartMode = {
	.MM2S_DMACR = {.offset = 0x00, .mask = 0xffffffff, .value = 0x00011003},
	//      ...     //  NOTE: not shown here for simplicity
	.S2MM_DMACR = {.offset = 0x30, .mask = 0xffffffff, .value = 0x00011003},
	.S2MM_DMASR = {.offset = 0x34, .mask = 0x00000000, .value = 0xffffffff},
	//      ...     //  NOTE: not shown here for simplicity
	.MM2S_VSIZE = {.offset = 0x50, .mask = 0x00000000, .value = 0xffffffff},
	.MM2S_HSIZE = {.offset = 0x54, .mask = 0x00000000, .value = 0xffffffff},
	.MM2S_FRMDLY_STRIDE  = {.offset = 0x58, .mask = 0x00000000, .value = 0xffffffff},
	.MM2S_START_ADDRESS1 = {.offset = 0x5c, .mask = 0x00000000, .value = 0xffffffff},
	.MM2S_START_ADDRESS2 = {.offset = 0x60, .mask = 0x00000000, .value = 0xffffffff},
	.MM2S_START_ADDRESS3 = {.offset = 0x64, .mask = 0x00000000, .value = 0xffffffff},
	//      ...     //  NOTE: not shown here for simplicity
	.S2MM_VSIZE = {.offset = 0xa0, .mask = 0x00000000, .value = 0xffffffff},
	.S2MM_HSIZE = {.offset = 0xa4, .mask = 0x00000000, .value = 0xffffffff},
	.S2MM_FRMDLY_STRIDE  = {.offset = 0xa8, .mask = 0x00000000, .value = 0xffffffff},
	.S2MM_START_ADDRESS1 = {.offset = 0xac, .mask = 0x00000000, .value = 0xffffffff},
	.S2MM_START_ADDRESS2 = {.offset = 0xb0, .mask = 0x00000000, .value = 0xffffffff},
	.S2MM_START_ADDRESS3 = {.offset = 0xb4, .mask = 0x00000000, .value = 0xffffffff}
	//      ...     //  NOTE: not shown here for simplicity
};


VDMAIPRegMap VDMAIPStopMode = {
		.MM2S_DMACR = {.offset = 0x00, .mask = 0x00000001, .value = 0x00000000},
		//      ...     //  NOTE: not shown here for simplicity
		.S2MM_DMACR = {.offset = 0x30, .mask = 0x00000001, .value = 0x00000000},
		.S2MM_DMASR = {.offset = 0x34, .mask = 0x00000000, .value = 0xffffffff},
		//      ...     //  NOTE: not shown here for simplicity
		.MM2S_VSIZE = {.offset = 0x50, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_HSIZE = {.offset = 0x54, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_FRMDLY_STRIDE  = {.offset = 0x58, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_START_ADDRESS1 = {.offset = 0x5c, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_START_ADDRESS2 = {.offset = 0x60, .mask = 0x00000000, .value = 0xffffffff},
		.MM2S_START_ADDRESS3 = {.offset = 0x64, .mask = 0x00000000, .value = 0xffffffff},
		//      ...     //  NOTE: not shown here for simplicity
		.S2MM_VSIZE = {.offset = 0xA0, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_HSIZE = {.offset = 0xA4, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_FRMDLY_STRIDE  = {.offset = 0xA8, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_START_ADDRESS1 = {.offset = 0xAc, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_START_ADDRESS2 = {.offset = 0xB0, .mask = 0x00000000, .value = 0xffffffff},
		.S2MM_START_ADDRESS3 = {.offset = 0xB4, .mask = 0x00000000, .value = 0xffffffff}
		//      ...     //  NOTE: not shown here for simplicity
};






#define VDMAIP_BUSY_STATUS_REG_offset 0x34
#define VDMAIP_BUSY_STATUS_REG_bit 1          // little endian convention [31:0]




// API to configure VDMA_IP
void VDMAIP_Driver_initialize(VDMAIPDriverInstance *InstancePtr);
void VDMAIP_Driver_start(VDMAIPDriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime);
void VDMAIP_Driver_stop(VDMAIPDriverInstance *InstancePtr);
bool VDMAIP_Driver_isBusy(VDMAIPDriverInstance *InstancePtr);





#endif 



// NOTE: everything seems to be auto-generatable!!



    
    
    
    
    
    
    
    
