// TODO: Implement this driver!!


#ifndef __GRAYSCALEIP_RULE2DRIVER_TEMPLATE_H__
#define __GRAYSCALEIP_RULE2DRIVER_TEMPLATE_H__



#define bool unsigned char


typedef struct {
    unsigned int baseaddr;
} GrayscaleIPRule2DriverInstance;


typedef struct {
    unsigned int offset;
    unsigned int value;
    unsigned int mask;
} GrayscaleIPRule2RegType;



// register map for Grayscale IP peripheral registers
typedef struct {
	GrayscaleIPRule2RegType AP_CTRL;
	GrayscaleIPRule2RegType GIE;
	GrayscaleIPRule2RegType IER;
	GrayscaleIPRule2RegType ISR;
	GrayscaleIPRule2RegType ROWS_DATA;
	GrayscaleIPRule2RegType COLS_DATA;
} GrayscaleIPRule2RegMap;

    
    
void localWriteReg(unsigned int addr, unsigned int mask, unsigned int value);
unsigned int localReadReg(unsigned int addr);
void SetHAMode(GrayscaleIPRule2RegMap mode, unsigned int baseaddr);




// the IP supplier should modify the contents of below register map to initialize the Grayscale IP peripheral
// the modified content will be written to the Grayscale IP's registers when initialize method is called by using SetHAMode
// the format is {offset, mask, value} --- if a register is not to be written then simply make mask 0x0
GrayscaleIPRul2RegMap GrayscaleIPRule2InitMode = {
		.AP_CTRL = {.offset = 0x00, .mask = 0x00000081, .value = 0x00000081},
		.GIE = {.offset = 0x04, .mask = 0x00000001, .value = 0x00000001},
		.IER = {.offset = 0x08, .mask = 0x00000001, .value = 0x00000000},
		.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
		.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
		.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
};

// the IP supplier should modify the contents of below register map to trigger the Grayscale IP peripheral to start processing
// the modified content will be written to the Grayscale IP's registers when start method is called by using SetHAMode
// the format is {offset, mask, value} --- if a register is not to be written then simply make mask 0x0
GrayscaleIPRule2RegMap GrayscaleIPRule2StartMode = {
		.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
		.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
		.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
		.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
		.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
		.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
};

// the IP supplier should modify the contents of below register map to stop the Grayscale IP peripheral's current processing
// the modified content will be written to the Grayscale IP's registers when stop method is called by using SetHAMode
// the format is {offset, mask, value} --- if a register is not to be written then simply make mask 0x0
GrayscaleIPRule2RegMap GrayscaleIPRule2StopMode = {
		.AP_CTRL = {.offset = 0x00, .mask = 0x00000001, .value = 0x00000000},
		.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
		.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
		.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
		.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
		.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
};




// the IP supplier should modify the contents of below register to be able to monitor the status of IP processing
#define BUSY_STATUS_REG_offset 0xff
#define BUSY_STATUS_REG_bit 31          // little endian convention [31:0]



// API for GrayscaleIP_Driver to use if this rule is applied by GRIP
void GrayscaleIP_Rule2Driver_initialize(GrayscaleIPRule2DriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime);
void GrayscaleIP_Rule2Driver_start(GrayscaleIPRule2DriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime);
void GrayscaleIP_Rule2Driver_stop(GrayscaleIPRule2DriverInstance *InstancePtr);
bool GrayscaleIP_Rule2Driver_isBusy(GrayscaleIPRule2DriverInstance *InstancePtr);






#endif




// NOTE: everything seems to be auto-generatable!!











