// this driver corresponds to Grayscale IP configuration corresponding to GRIP Rule 1 i.e Grayscale IP integrated with AXI-VDMA 
// it is generated by modifying the auto-generated template


#ifndef __GRAYSCALEIP_DRIVER_H__
#define __GRAYSCALEIP_DRIVER_H__


#include "VDMAIP_Driver.h"


#define bool unsigned char

// all the hardware related info needed by the driver functions should be provided in this struct
typedef struct {
    unsigned int baseaddr;
    VDMAIPDriverInstance vdmaDriver;
} GrayscaleIPDriverInstance;


typedef struct {
    unsigned int offset;
    unsigned int value;
    unsigned int mask;
} GrayscaleIPRegType;



// register map for Grayscale IP peripheral registers
typedef struct {
	GrayscaleIPRegType AP_CTRL;
	GrayscaleIPRegType GIE;
	GrayscaleIPRegType IER;
	GrayscaleIPRegType ISR;
	GrayscaleIPRegType ROWS_DATA;
	GrayscaleIPRegType COLS_DATA;
} GrayscaleIPRegMap;

    
    
static void localWriteReg(unsigned int addr, unsigned int mask, unsigned int value);
static unsigned int localReadReg(unsigned int addr);
static void SetHAMode(GrayscaleIPRegType mode, unsigned int baseaddr);




// Modified the template to initialize GrayscaleIP
GrayscaleIPRegType InitMode;
InitMode.AP_CTRL = {0x00, 0x00000081, 0x00000081};       // ap_start = '1', ap_autorestart = '1', ap_done = '0'
InitMode.GIE = {0x04, 0x00000001, 0x00000001};           // global_interrupt_enable = '1'
InitMode.IER = {0x08, 0x00000001, 0x00000000};           // ap_done = '0' (no interrupt on done)
InitMode.ISR = {0x0c, 0x00000000, 0xffffffff};           // do nothing
InitMode.ROWS_DATA = {0x14, 0x00000000, 0xffffffff};     // do nothing....rows will be set in "start" method
InitMode.COLS_DATA = {0x1c, 0x00000000, 0xffffffff};     // do nothing....rows will be set in "start" method

// No need to set any register here apart from rows_data, cols_data but that is runtime dependent so get that via argument
GrayscaleIPRegType StartMode;
StartMode.AP_CTRL = {0x00, 0x00000000, 0xffffffff};
StartMode.GIE = {0x04, 0x00000000, 0xffffffff};
StartMode.IER = {0x08, 0x00000000, 0xffffffff};
StartMode.ISR = {0x0c, 0x00000000, 0xffffffff};
StartMode.ROWS_DATA = {0x14, 0x00000000, 0xffffffff};
StartMode.COLS_DATA = {0x1c, 0x00000000, 0xffffffff};

// Modified the template to stop Grayscale processing
GrayscaleIPRegType StopMode;
StopMode.AP_CTRL = {0x00, 0x00000001, 0x00000000};
StopMode.GIE = {0x04, 0x00000000, 0xffffffff};
StopMode.IER = {0x08, 0x00000000, 0xffffffff};
StopMode.ISR = {0x0c, 0x00000000, 0xffffffff};
StopMode.ROWS_DATA = {0x14, 0x00000000, 0xffffffff};
StopMode.COLS_DATA = {0x1c, 0x00000000, 0xffffffff};



#define BUSY_STATUS_REG_offset 0x0c
#define BUSY_STATUS_REG_bit 1          // little endian convention [31:0]



// API for GrayscaleIP_Driver to use if this rule is applied by GRIP
// NOTE: if any of the functions requires runtime info then their prototype should be matched with _SW() function
void GrayscaleIP_Driver_initialize(GrayscaleIPDriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime);
void GrayscaleIP_Driver_start(GrayscaleIPDriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime);
void GrayscaleIP_Driver_stop(GrayscaleIPDriverInstance *InstancePtr);         
bool GrayscaleIP_Driver_isBusy(GrayscaleIPDriverInstance *InstancePtr);

// NOTE: for now _stop(), _isBusy() are not expected to take in any realtime info from SW so they have no arguments but if they need it in future then they should have same arguments as that of _initialize(), _start() methods to make the job of code-generator easier!!





#endif













