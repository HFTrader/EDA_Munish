// this driver corresponds to Grayscale IP configuration corresponding to GRIP Rule 1 i.e Grayscale IP integrated with AXI-VDMA 
// it is generated by modifying the auto-generated template

#include "GrayscaleIP_Rule1Driver.h"


GrayscaleIPRule1RegMap GrayscaleIPRule1InitMode = {
													.AP_CTRL = {.offset = 0x00, .mask = 0x00000081, .value = 0x00000081},
													.GIE = {.offset = 0x04, .mask = 0x00000001, .value = 0x00000001},
													.IER = {.offset = 0x08, .mask = 0x00000001, .value = 0x00000000},
													.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
													.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
													.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
											      };


GrayscaleIPRule1RegMap GrayscaleIPRule1StartMode = {
													.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
													.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
													.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
													.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
													.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
													.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
												  };


GrayscaleIPRule1RegMap GrayscaleIPRule1StopMode = {
													.AP_CTRL = {.offset = 0x00, .mask = 0x00000001, .value = 0x00000000},
													.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
													.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
													.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
													.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
													.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
												  };


static void localWriteReg(unsigned int addr, unsigned int mask, unsigned int value) {
    // only write to reg if mask != 0
    if ((mask | 0x0) != 0x0) {
        *((volatile unsigned int *)(addr)) = (*(volatile unsigned int *)(addr) & ~(mask)) | value;
    }
}


static unsigned int localReadReg(unsigned int addr) {
    return (unsigned int) *((volatile unsigned int *)(addr));
}


// updates the Grayscale IP peripheral's memory mapped registers with content provided in mode 
static void SetHAMode(GrayscaleIPRule1RegMap mode, unsigned int baseaddr) {
	localWriteReg(baseaddr + mode.AP_CTRL.offset, mode.AP_CTRL.mask, mode.AP_CTRL.value);
	localWriteReg(baseaddr + mode.GIE.offset, mode.GIE.mask, mode.GIE.value);
	localWriteReg(baseaddr + mode.IER.offset, mode.IER.mask, mode.IER.value);
	localWriteReg(baseaddr + mode.ISR.offset, mode.ISR.mask, mode.ISR.value);
	localWriteReg(baseaddr + mode.ROWS_DATA.offset, mode.ROWS_DATA.mask, mode.ROWS_DATA.value);
	localWriteReg(baseaddr + mode.COLS_DATA.offset, mode.COLS_DATA.mask, mode.COLS_DATA.value);
}


void GrayscaleIP_Rule1Driver_initialize(GrayscaleIPRule1DriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime) {
    // initializing GrayscaleIP
	GrayscaleIPRule1InitMode.ROWS_DATA.mask = 0xffffffff;
	GrayscaleIPRule1InitMode.ROWS_DATA.value = width;

	GrayscaleIPRule1InitMode.COLS_DATA.mask = 0xffffffff;
	GrayscaleIPRule1InitMode.COLS_DATA.value = height;

	SetHAMode(GrayscaleIPRule1InitMode, InstancePtr->baseaddr);

    // for this rule we also need to initialize the connected VDMA as well
    VDMAIP_Driver_initialize(&InstancePtr->vdmaDriver);
}



void GrayscaleIP_Rule1Driver_start(GrayscaleIPRule1DriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime) {
    // following is not needed as we haven't updated any register
    // SetHAMode(StartMode, InstancePtr->baseaddr);        
    
    // starting the VDMA whose driver will configure its MEM2DEV path as well as DEV2MEM path
    VDMAIP_Driver_start(&InstancePtr->vdmaDriver, ImgIn_BaseAddr, ImgOut_BaseAddr, width, height, horizontalActiveTime, verticalActiveTime);
}



void GrayscaleIP_Rule1Driver_stop(GrayscaleIPRule1DriverInstance *InstancePtr) {
    // stopping GrayscaleIP
	SetHAMode(GrayscaleIPRule1StopMode, InstancePtr->baseaddr);
    
    // stopping VDMA as well
    VDMAIP_Driver_stop(&InstancePtr->vdmaDriver);
}


bool GrayscaleIP_Rule1Driver_isBusy(GrayscaleIPRule1DriverInstance *InstancePtr) {
	printf("%x\r\n", localReadReg(InstancePtr->baseaddr + 0x0));
	printf("%x\r\n", localReadReg(InstancePtr->baseaddr + 0x4));
	printf("%x\r\n", localReadReg(InstancePtr->baseaddr + 0x8));
	printf("%x\r\n", localReadReg(InstancePtr->baseaddr + 0xc));
	printf("%x\r\n", localReadReg(InstancePtr->baseaddr + 0x14));
	printf("%x\r\n", localReadReg(InstancePtr->baseaddr + 0x1c));
    // not using VDMA S2MM busy signal for now as documentation states we have to use scatter-gather mode to read in Idle
    // TODO: see if you can read in VDMA busy signal as well then driver would be more complete...i.e return busy status = '1' only if both the IP as well as the VDMA S2MM are free
    return (bool) !((localReadReg(InstancePtr->baseaddr + GRAYSCALEIPRULE1_BUSY_STATUS_REG_offset) >> GRAYSCALEIPRULE1_BUSY_STATUS_REG_bit) & 1);
}















