// this is a template file which will be auto-generated by GRIP framework by using the IP-Xact description provided by this IP corresponding to Rule1 (Erode filter + VDMA) 
// The IP supplier can then fill in this template to generate his driver targeting a specific platform

// for now it is simulated i.e it is a sample representation of the actual template file which doesnt contain all the registers of this IP


#include "ErodeIP_Rule1Driver_template.h"



ErodeIPRule1RegMap ErodeIPRule1InitMode = {
											.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
											.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
											.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
											.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
											.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
											.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
									      };


ErodeIPRule1RegMap ErodeIPRule1StartMode = {
											.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
											.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
											.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
											.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
											.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
											.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
										   };


ErodeIPRule1RegMap ErodeIPRule1StopMode = {
											.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
											.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
											.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
											.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
											.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
											.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
										  };
												  


static void localWriteReg(unsigned int addr, unsigned int mask, unsigned int value) {
    // only write to reg if mask != 0
    if ((mask | 0x0) != 0x0) {
    *((volatile unsigned int *)(addr)) = (*(volatile unsigned int *)(addr) & ~(mask)) | value;
	}
}


static unsigned int localReadReg(unsigned int addr) {
    return (unsigned int) *((volatile unsigned int *)(addr));
}


// updates the Erode IP peripheral's memory mapped registers with content provided in mode 
static void SetHAMode(ErodeIPRule1RegMap mode, unsigned int baseaddr) {
	localWriteReg(baseaddr + mode.AP_CTRL.offset, mode.AP_CTRL.mask, mode.AP_CTRL.value);
	localWriteReg(baseaddr + mode.GIE.offset, mode.GIE.mask, mode.GIE.value);
	localWriteReg(baseaddr + mode.IER.offset, mode.IER.mask, mode.IER.value);
	localWriteReg(baseaddr + mode.ISR.offset, mode.ISR.mask, mode.ISR.value);
	localWriteReg(baseaddr + mode.ROWS_DATA.offset, mode.ROWS_DATA.mask, mode.ROWS_DATA.value);
	localWriteReg(baseaddr + mode.COLS_DATA.offset, mode.COLS_DATA.mask, mode.COLS_DATA.value);
}

// the IP supplier should make necessary modifications to initialize the Erode IP here
void ErodeIP_Rule1Driver_initialize(ErodeIPRule1DriverInstance *InstancePtr, XScuGic *InterruptController) {
    // initializing the IP module
    SetHAMode(ErodeIPRule1InitMode, InstancePtr->baseaddr);   

    // for this rule we also need to initialize the connected VDMA as well
    ERODEIP_VDMA_Driver_initialize(&InstancePtr->vdmaDriver);    

	// registering this IP's ISR with the Interrupt Controller passed on by the application developer 
	int Status = XScuGic_Connect(InterruptController, InstancePtr->intr_id, (Xil_ExceptionHandler) GrayscaleIP_ISR, (void *) InstancePtr);
	if (Status != XST_SUCCESS) {
		Xil_AssertVoid(0);
	}
	XScuGic_Enable(InterruptController, InstancePtr->intr_id);
}


// the IP supplier should make necessary modifications to trigger the Erode IP to start processing here
void ErodeIP_Rule1Driver_start(ErodeIPRule1DriverInstance *InstancePtr) {
    SetHAMode(ErodeIPRule1StartMode, InstancePtr->baseaddr);
    
    ERODEIP_VDMA_Driver_start(&InstancePtr->vdmaDriver);

	InstancePtr->busy = 1;
}


// the IP supplier should make necessary modifications to stop the Erode IP processing here
void ErodeIP_Rule1Driver_stop(ErodeIPRule1DriverInstance *InstancePtr) {
	// stopping ErodeIP
    SetHAMode(ErodeIPRule1StopMode, InstancePtr->baseaddr);

	// stopping VDMA as well
	ERODEIP_VDMA_Driver_stop(&InstancePtr->vdmaDriver);
}

// the IP supplier should make necessary modifications to inform about the Busy status here
bool ErodeIP_Rule1Driver_isBusy(ErodeIPRule1DriverInstance *InstancePtr) {
	return InstancePtr->busy;
}


void ErodeIP_ISR(void *baseaddr_p)
{
	ErodeIPRule1DriverInstance *InstancePtr = (ErodeIPRule1DriverInstance *) baseaddr_p;

	InstancePtr->busy = 0;
}




