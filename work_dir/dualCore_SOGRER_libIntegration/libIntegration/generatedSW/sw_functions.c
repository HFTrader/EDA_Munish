// this SW module would be generated by the code generator during the library integration step
// provides the implementation for each of the method defined in "sw_functions API"
// Each of the method is HA aware i.e if HA is available to do this task then use it else do it on CPU (SW implementation)....so this module is doing HW/SW task allocation at runtime


// TODO: auto-generate this module during library integration process



#include "sw_functions.h"


static unsigned int num_grayscale_ha_initialized = 0;

void Grayscale_processInit(XScuGic *InterruptController, unsigned short frameRows, unsigned short frameCols, unsigned long CONTROL_BUS_BASEADDRESS, unsigned long VDMA_BASEADDR, unsigned int VDMA_INTR_ID) {
    if (num_grayscale_ha_initialized == NUM_GRAYSCALE_HA || NUM_GRAYSCALE_HA == 0) {
        exit(1);            // error condition -- this shouldn't happen!!
    } else {
        GrayscaleIP_initialize(&GrayscaleFilters[num_grayscale_ha_initialized], InterruptController, frameRows, frameCols, CONTROL_BUS_BASEADDRESS, VDMA_BASEADDR, VDMA_INTR_ID);
    }
    num_grayscale_ha_initialized++;
}




void Grayscale_process(unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime) {
    unsigned char freeHA_found = 0;
#if NUM_GRAYSCALE_HA == 0
    ConvToGray(ImgIn_BaseAddr, ImgOut_BaseAddr, width, height, horizontalActiveTime);
#else
    for (int i=0; i<NUM_GRAYSCALE_HA; i++) {
        if (GrayscaleIP_isBusy(&GrayscaleFilters[i]) == 0) {
            GrayscaleIP_trigger(&GrayscaleFilters[i], ImgIn_BaseAddr, ImgOut_BaseAddr, width, height, horizontalActiveTime);
            freeHA_found = 1;
            break;
        }
    }    
    if (freeHA_found == 0) {
        ConvToGray(ImgIn_BaseAddr, ImgOut_BaseAddr, width, height, horizontalActiveTime);
    }
}
        



