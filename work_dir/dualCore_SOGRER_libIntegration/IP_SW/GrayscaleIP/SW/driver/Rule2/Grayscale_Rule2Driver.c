// this driver corresponds to Grayscale IP configuration corresponding to GRIP Rule 2 i.e Grayscale IP only
// it is generated by modifying the auto-generated template

#include "Grayscale_Rule2Driver.h"
#include "xil_assert.h"

// NOTE: the value maps in the following are got using IP-Xact descriptions from GRIP and individual IPs
// NOTE: these are modified by IP supplier to perform the desired functionality

Grayscale_Rule2_RegMap Rule2_InitMode = {
                ._GrayscaleIP_RegMap = {
										.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
										.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
										.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
										.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
										.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
										.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
									  }
           };


Grayscale_Rule2_RegMap Rule2_StartMode = {
                ._GrayscaleIP_RegMap = {
										.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
										.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
										.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
										.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
										.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
										.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
									  }
           };

Grayscale_Rule2_RegMap Rule2_StopMode = {
                ._GrayscaleIP_RegMap = {
										.AP_CTRL = {.offset = 0x00, .mask = 0x00000000, .value = 0xffffffff},
										.GIE = {.offset = 0x04, .mask = 0x00000000, .value = 0xffffffff},
										.IER = {.offset = 0x08, .mask = 0x00000000, .value = 0xffffffff},
										.ISR = {.offset = 0x0c, .mask = 0x00000000, .value = 0xffffffff},
										.ROWS_DATA = {.offset = 0x14, .mask = 0x00000000, .value = 0xffffffff},
										.COLS_DATA = {.offset = 0x1c, .mask = 0x00000000, .value = 0xffffffff}
									  }
           };



void Grayscale_Rule2Driver_initialize(Grayscale_Rule2_DriverInstance *InstancePtr, XScuGic *InterruptController, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime) {
    // initializing the GrayscaleIP
    GrayscaleIP_Driver_initialize(&InstancePtr->_GrayscaleIP_DriverInstance, InterruptController, Rule2_InitMode._GrayscaleIP_RegMap, 0, 0, 0, 0, 0, 0);
}



void Grayscale_Rule2Driver_start(Grayscale_Rule2_DriverInstance *InstancePtr, unsigned long ImgIn_BaseAddr,unsigned long ImgOut_BaseAddr,unsigned short width, unsigned short height, unsigned short horizontalActiveTime, unsigned short verticalActiveTime) {
	// starting the GrayscaleIP
	GrayscaleIP_Driver_start(&InstancePtr->_GrayscaleIP_DriverInstance, Rule2_StartMode._GrayscaleIP_RegMap, 0, 0, 0, 0, 0, 0);
}



void Grayscale_Rule2Driver_stop(Grayscale_Rule2_DriverInstance *InstancePtr) {
	// stopping GrayscaleIP
	GrayscaleIP_Driver_stop(&InstancePtr->_GrayscaleIP_DriverInstance, Rule2_StopMode._GrayscaleIP_RegMap);
}



bool Grayscale_Rule2Driver_isBusy(Grayscale_Rule2_DriverInstance *InstancePtr) {
	//return GrayscaleIP_Driver_isBusy(&InstancePtr->_GrayscaleIP_DriverInstance);

	// designing this to be always busy!!
	return 1;
}










