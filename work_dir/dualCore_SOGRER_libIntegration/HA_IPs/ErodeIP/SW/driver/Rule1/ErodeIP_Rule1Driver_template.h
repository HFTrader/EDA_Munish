// this is a template file which will be auto-generated by GRIP framework by using the IP-Xact description provided by this IP corresponding to Rule1 (Erode filter + VDMA) 
// The IP supplier can then fill in this template to generate his driver targeting a specific platform

// NOTE: for now it is simulated i.e it is a sample representation of the actual template file which doesnt contain all the registers of this IP



#ifndef __ERODEIP_RULE1DRIVER_TEMPLATE_H__
#define __ERODEIP_RULE1DRIVER_TEMPLATE_H__


#include "ErodeIP_VDMA_Driver.h"


#define bool unsigned char


// all the hardware related info needed by the driver functions should be provided in this struct
typedef struct {
    unsigned int baseaddr;
    ERODEIP_VDMADriverInstance vdmaDriver;
    unsigned int grip_rule;
} ErodeIPRule1DriverInstance;


typedef struct {
    unsigned int offset;
    unsigned int value;
    unsigned int mask;
} ErodeIPRule1RegType;



// register map for Grayscale IP peripheral registers
typedef struct {
	ErodeIPRule1RegType AP_CTRL;
	ErodeIPRule1RegType GIE;
	ErodeIPRule1RegType IER;
	ErodeIPRule1RegType ISR;
	ErodeIPRule1RegType ROWS_DATA;
	ErodeIPRule1RegType COLS_DATA;
} ErodeIPRule1RegMap;



// the IP supplier should modify the contents of below register to be able to monitor the status of IP processing
#define ERODEIPRULE1_BUSY_STATUS_REG_offset 0xff
#define ERODEIPRULE1_BUSY_STATUS_REG_bit 31          // little endian convention [31:0]



// API for GrayscaleIP_Driver to use if this rule is applied by GRIP
void ErodeIP_Rule1Driver_initialize(ErodeIPRule1DriverInstance *InstancePtr);
void ErodeIP_Rule1Driver_start(ErodeIPRule1DriverInstance *InstancePtr);
void ErodeIP_Rule1Driver_stop(ErodeIPRule1DriverInstance *InstancePtr);
bool ErodeIP_Rule1Driver_isBusy(ErodeIPRule1DriverInstance *InstancePtr);



#endif




// NOTE: everything seems to be auto-generatable!!











