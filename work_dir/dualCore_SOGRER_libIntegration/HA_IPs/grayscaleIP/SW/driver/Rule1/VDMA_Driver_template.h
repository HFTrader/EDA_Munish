// this is a template file which will be auto-generated by GRIP framework by using the IP-Xact description provided by this IP 
// The IP supplier can then fill in this template to generate his driver targeting a specific platform

// NOTE: for now it is simulated i.e it is a sample representation of the actual template file which doesnt contain all the registers of this IP



#ifndef __VDMAIP_DRIVER_TEMPLATE_H__
#define __VDMAIP_DRIVER_TEMPLATE_H__

#define bool unsigned char


typedef struct {
    unsigned int baseaddr;
} VDMAIPDriverInstance;


typedef struct {
    unsigned int offset;
    unsigned int value;
    unsigned int mask;
} RegType;




// register map for VDMA IP registers
typedef struct {
    // actual Xilinx AXI-VDMA IP has ~55 registers.....for now only a sample of registers are shown to provide an idea
    // only registers important for IP use are shown here...but in actual auto-generated file, all the registers will be present    
    RegType MM2S_DMACR;
    //      ...     //  NOTE: not shown here for simplicity
    RegType S2MM_DMACR;
    RegType S2MM_DMASR;
    //      ...     //  NOTE: not shown here for simplicity
    RegType MM2S_VSIZE;
    RegType MM2S_HSIZE;
    RegType MM2S_FRMDLY_STRIDE;
    RegType MM2S_START_ADDRESS1;
    RegType MM2S_START_ADDRESS2;
    RegType MM2S_START_ADDRESS3;
    //      ...     //  NOTE: not shown here for simplicity
    RegType S2MM_VSIZE;
    RegType S2MM_HSIZE;
    RegType S2MM_FRMDLY_STRIDE;
    RegType S2MM_START_ADDRESS1;
    RegType S2MM_START_ADDRESS2;
    RegType S2MM_START_ADDRESS3;
    //      ...     //  NOTE: not shown here for simplicity
} RegMap;


    
void localWriteReg(unsigned int addr, unsigned int mask, unsigned int value);
unsigned int localReadReg(unsigned int addr);
void SetHAMode(RegMap mode, unsigned int baseaddr);


// the IP supplier should modify the contents of below register map to initialize the VDMA IP
// the modified content will be written to the VDMA IP's registers when initialize method is called by using SetHAMode
// the format is {offset, mask, value} --- if a register is not to be written then simply make mask 0x0
RegMap InitMode;
InitMode.MM2S_DMACR = {0x00, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
InitMode.S2MM_DMACR = {0x30, 0x00000000, 0xffffffff};
InitMode.S2MM_DMASR = {0x34, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
InitMode.MM2S_VSIZE = {0x50, 0x00000000, 0xffffffff};
InitMode.MM2S_HSIZE = {0x54, 0x00000000, 0xffffffff};
InitMode.MM2S_FRMDLY_STRIDE  = {0x58, 0x00000000, 0xffffffff};
InitMode.MM2S_START_ADDRESS1 = {0x5c, 0x00000000, 0xffffffff};
InitMode.MM2S_START_ADDRESS2 = {0x60, 0x00000000, 0xffffffff};
InitMode.MM2S_START_ADDRESS3 = {0x64, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
InitMode.S2MM_VSIZE = {0xA0, 0x00000000, 0xffffffff};
InitMode.S2MM_HSIZE = {0xA4, 0x00000000, 0xffffffff};
InitMode.S2MM_FRMDLY_STRIDE  = {0xA8, 0x00000000, 0xffffffff};
InitMode.S2MM_START_ADDRESS1 = {0xAc, 0x00000000, 0xffffffff};
InitMode.S2MM_START_ADDRESS2 = {0xB0, 0x00000000, 0xffffffff};
InitMode.S2MM_START_ADDRESS3 = {0xB4, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity





// the IP supplier should modify the contents of below register map to trigger the VDMA IP peripheral to start processing
// the modified content will be written to the VDMA IP's registers when start method is called by using SetHAMode
// the format is {offset, mask, value} --- if a register is not to be written then simply make mask 0x0
RegMap StartMode;
StartMode.MM2S_DMACR = {0x00, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
StartMode.S2MM_DMACR = {0x30, 0x00000000, 0xffffffff};
StartMode.S2MM_DMASR = {0x34, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
StartMode.MM2S_VSIZE = {0x50, 0x00000000, 0xffffffff};
StartMode.MM2S_HSIZE = {0x54, 0x00000000, 0xffffffff};
StartMode.MM2S_FRMDLY_STRIDE  = {0x58, 0x00000000, 0xffffffff};
StartMode.MM2S_START_ADDRESS1 = {0x5c, 0x00000000, 0xffffffff};
StartMode.MM2S_START_ADDRESS2 = {0x60, 0x00000000, 0xffffffff};
StartMode.MM2S_START_ADDRESS3 = {0x64, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
StartMode.S2MM_VSIZE = {0xA0, 0x00000000, 0xffffffff};
StartMode.S2MM_HSIZE = {0xA4, 0x00000000, 0xffffffff};
StartMode.S2MM_FRMDLY_STRIDE  = {0xA8, 0x00000000, 0xffffffff};
StartMode.S2MM_START_ADDRESS1 = {0xAc, 0x00000000, 0xffffffff};
StartMode.S2MM_START_ADDRESS2 = {0xB0, 0x00000000, 0xffffffff};
StartMode.S2MM_START_ADDRESS3 = {0xB4, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity




// the IP supplier should modify the contents of below register map to stop the VDMA IP peripheral's current processing
// the modified content will be written to the VDMA IP's registers when stop method is called by using SetHAMode
// the format is {offset, mask, value} --- if a register is not to be written then simply make mask 0x0
RegMap StopMode;
StopMode.MM2S_DMACR = {0x00, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
StopMode.S2MM_DMACR = {0x30, 0x00000000, 0xffffffff};
StopMode.S2MM_DMASR = {0x34, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
StopMode.MM2S_VSIZE = {0x50, 0x00000000, 0xffffffff};
StopMode.MM2S_HSIZE = {0x54, 0x00000000, 0xffffffff};
StopMode.MM2S_FRMDLY_STRIDE  = {0x58, 0x00000000, 0xffffffff};
StopMode.MM2S_START_ADDRESS1 = {0x5c, 0x00000000, 0xffffffff};
StopMode.MM2S_START_ADDRESS2 = {0x60, 0x00000000, 0xffffffff};
StopMode.MM2S_START_ADDRESS3 = {0x64, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity
StopMode.S2MM_VSIZE = {0xA0, 0x00000000, 0xffffffff};
StopMode.S2MM_HSIZE = {0xA4, 0x00000000, 0xffffffff};
StopMode.S2MM_FRMDLY_STRIDE  = {0xA8, 0x00000000, 0xffffffff};
StopMode.S2MM_START_ADDRESS1 = {0xAc, 0x00000000, 0xffffffff};
StopMode.S2MM_START_ADDRESS2 = {0xB0, 0x00000000, 0xffffffff};
StopMode.S2MM_START_ADDRESS3 = {0xB4, 0x00000000, 0xffffffff};
//      ...     //  NOTE: not shown here for simplicity




// the IP supplier should modify the contents of below register to be able to monitor the status of IP processing
#define BUSY_STATUS_REG_offset 0xff
#define BUSY_STATUS_REG_bit 31          // little endian convention [31:0]




// API to configure VDMA_IP
void VDMAIP_Driver_initialize(VDMAIPDriverInstance *InstancePtr);
void VDMAIP_Driver_start(VDMAIPDriverInstance *InstancePtr);
void VDMAIP_Driver_stop(VDMAIPDriverInstance *InstancePtr);
bool VDMAIP_Driver_isBusy(VDMAIPDriverInstance *InstancePtr);


#endif 



// NOTE: everything seems to be auto-generatable!!



    
    
    
    
    
    
    
    
