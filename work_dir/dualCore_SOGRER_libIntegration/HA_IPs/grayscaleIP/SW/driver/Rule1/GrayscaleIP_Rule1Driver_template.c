// this is a template file which will be auto-generated by GRIP framework by using the IP-Xact description provided by this IP corresponding to Rule1 (Grayscale filter + VDMA) 
// The IP supplier can then fill in this template to generate his driver targeting a specific platform

// for now it is simulated i.e it is a sample representation of the actual template file which doesnt contain all the registers of this IP


#include "GrayscaleIP_Driver_template.h"


void localWriteReg(unsigned int addr, unsigned int mask, unsigned int value) {
    // only write to reg if mask != 0
    if (mask | 0x0 != 0x0) {
    *((volatile unsigned int *)(addr)) = (*(volatile unsigned int *)(addr) & ~(mask)) | value;
	}
}


unsigned int localReadReg(unsigned int addr) {
    return (unsigned int) *((volatile unsigned int *)(addr));
}


// updates the Grayscale IP peripheral's memory mapped registers with content provided in mode 
void SetHAMode(RegMap mode, unsigned int baseaddr) {
	localWriteReg(baseaddr + mode.AP_CTRL.offset, mode.AP_CTRL.mask, mode.AP_CTRL.value);
	localWriteReg(baseaddr + mode.GIE.offset, mode.GIE.mask, mode.GIE.value);
	localWriteReg(baseaddr + mode.IER.offset, mode.IER.mask, mode.IER.value);
	localWriteReg(baseaddr + mode.ISR.offset, mode.ISR.mask, mode.ISR.value);
	localWriteReg(baseaddr + mode.ROWS_DATA.offset, mode.ROWS_DATA.mask, mode.ROWS_DATA.value);
	localWriteReg(baseaddr + mode.COLS_DATA.offset, mode.COLS_DATA.mask, mode.COLS_DATA.value);
}

// the IP supplier should make necessary modifications to initialize the Grayscale IP here
void GrayscaleIP_Driver_initialize(GrayscaleIPDriverInstance *InstancePtr) {
    // initializing the IP module
    SetHAMode(InitMode, IntancePtr->baseaddr);   

    // for this rule we also need to initialize the connected VDMA as well
    VDMAIP_Driver_initialize(&InstancePtr->vdmaDriver);        
}


// the IP supplier should make necessary modifications to trigger the Grayscale IP to start processing here
void GrayscaleIP_Driver_start(GrayscaleIPDriverInstance *InstancePtr) {
    SetHAMode(StartMode, InstancePtr->baseaddr);
}


// the IP supplier should make necessary modifications to stop the Grayscale IP processing here
void GrayscaleIP_Driver_stop(GrayscaleIPDriverInstance *InstancePtr) {
    SetHAMode(StopMode, InstancePtr->baseaddr);
}

// the IP supplier should make necessary modifications to inform about the Busy status here
bool GrayscaleIP_Driver_isBusy(GrayscaleIPDriverInstance *InstancePtr) {    
    return (bool) ((localReadReg(InstancePtr->baseaddr + BUSY_STATUS_REG_offset) >> BUSY_STATUS_REG_bit) & 1);
}





