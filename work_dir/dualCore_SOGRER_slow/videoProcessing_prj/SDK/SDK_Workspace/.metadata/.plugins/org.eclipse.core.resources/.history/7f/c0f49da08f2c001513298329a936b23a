// NOTE: this would later be generated by the template engine using information from "SoC_config.h", "sw_functions.h"
// NOTE: right now simulating the scenario when there is a dual core ARM Cortex A9 on Zynq-PS and a Xilinx Microblaze core on Zynq-PL are available then the template engine would generate the following file

// TODO: consider the scenario when you have a zynq chip that contains a quad core arm cortex a9 processor and no other processor......in this case there are 3 cpus in SoC all of same type....what should be the template engine output then??????

#ifndef SOCPROC_SUPPORT_H_
#define SOCPROC_SUPPORT_H_

// NOTE: if ZYNQ-ARM CortexA9 core is present in SoC
#include "ZYNQ_ARM_CORTEX_A9_support.h"
// NOTE: if Xilinx Microblaze 8.5 IP core is present in SoC
#include "XIL_MICROBLAZE_8_5_support.h"
// NOTE: and so on for other processors in "SoC_config.h"

// NOTE; if ZYNQ-ARM CortexA9 core is present in SoC
#define ZYNQ_ARM_CORTEX_A9 0
// NOTE: if Xilinx Microblaze 8.5 IP core is present in SoC
#define XIL_MICROBLAZE_8_5 1
// NOTE: and so on for other processors in "SoC_config.h"

// NOTE: get total number of Processors in SoC from "SoC_config.h"
#define NUM_PROCS 2

typedef struct {
	unsigned char m_type;
	unsigned char m_id;
	unsigned char m_busy;
	unsigned int m_MEM_BASEADDR;
} SoCProc;

SoCProc *SoCProc_elements;

// API for application developer
// TODO: right now hardcoded seeing signature of processFrame in main().......should be able to have a random(void!) function pointer
void SoCProc_initialize(void(*ptr)(unsigned int)));
// NOTE: create callback function pointer from "sw_functions.h"
unsigned char SoCProc_processDataflow();


#endif


// all the code in this module shall be executed by Master CPU only!!
