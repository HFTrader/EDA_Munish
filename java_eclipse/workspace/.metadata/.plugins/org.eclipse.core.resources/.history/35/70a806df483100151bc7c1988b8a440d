import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.HashMap;
import java.util.Map;

import javax.swing.JFrame;
import javax.swing.JScrollPane;

import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTSimpleDeclaration;
import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTFunctionDeclarator;
import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTParameterDeclaration;
import org.eclipse.cdt.core.dom.ast.IASTDeclSpecifier;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTSimpleDeclSpecifier;
import org.eclipse.cdt.core.dom.ast.IASTPointerOperator;

import org.eclipse.cdt.core.dom.ast.IASTPreprocessorIncludeStatement;
import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
import org.eclipse.cdt.core.dom.ast.gnu.cpp.GPPLanguage;
import org.eclipse.cdt.core.parser.DefaultLogService;
import org.eclipse.cdt.core.parser.FileContent;
import org.eclipse.cdt.core.parser.IParserLogService;
import org.eclipse.cdt.core.parser.IScannerInfo;
import org.eclipse.cdt.core.parser.IncludeFileContentProvider;
import org.eclipse.cdt.core.parser.ScannerInfo;
import org.eclipse.core.runtime.CoreException;

import treeview.JTreeTable;
import treeview.ast.ASTTreeModel;

public class ASTViewer{
    public static void main( String[] args ) throws CoreException{
//        new ASTViewer();
    	FileContent fileContent = FileContent.createForExternalFileLocation("./docs/sw_functions.h");
    	
    	Map definedSymbols = new HashMap();
    	String[] includePaths = new String[0];
    	IScannerInfo info = new ScannerInfo(definedSymbols, includePaths);    	
    	IParserLogService log = new DefaultLogService();
    	IncludeFileContentProvider emptyIncludes = IncludeFileContentProvider.getEmptyFilesProvider();
    	IASTTranslationUnit translationUnit = GPPLanguage.getDefault().getASTTranslationUnit(fileContent, info, emptyIncludes, null, opts, log);
    }

//    public ASTViewer() throws CoreException { 
//        JFrame frame = new JFrame("ASTViewer");
//
//        //FileContent fileContent = FileContent.createForExternalFileLocation("./docs/DeviceManager.h");
//        FileContent fileContent = FileContent.createForExternalFileLocation("./docs/sw_functions.h");
//
//        Map definedSymbols = new HashMap(); 
//        String[] includePaths = new String[0];
//        IScannerInfo info = new ScannerInfo(definedSymbols, includePaths);
//        IParserLogService log = new DefaultLogService();
//
//        IncludeFileContentProvider emptyIncludes = IncludeFileContentProvider.getEmptyFilesProvider();
//
//        int opts = 8;
//        IASTTranslationUnit translationUnit = GPPLanguage.getDefault().getASTTranslationUnit(fileContent, info, emptyIncludes, null, opts, log);
//
//        IASTPreprocessorIncludeStatement[] includes = translationUnit.getIncludeDirectives();
//        for (IASTPreprocessorIncludeStatement include : includes) {
//            System.out.println("include - " + include.getName());
//        }
//
//        JTreeTable treeTable = new JTreeTable(new ASTTreeModel(translationUnit));
//
//        frame.addWindowListener(new WindowAdapter() {
//            public void windowClosing( WindowEvent we ) {
//                System.exit(0);
//            }
//        });
//        JScrollPane scrollPane = new JScrollPane(treeTable); 
//        frame.getContentPane().add(scrollPane);
//        frame.pack();
//        //frame.show();
//
//        
//        
//        
//        
//        IASTDeclaration[] declarations = translationUnit.getDeclarations();
//        for (IASTDeclaration declaration : declarations) {
//        	//System.out.println(declaration.getRawSignature());
//        	//System.out.println(declaration.getClass());
//        	if (declaration instanceof CPPASTSimpleDeclaration) {
//        		CPPASTSimpleDeclaration cppsimpledeclaration = (CPPASTSimpleDeclaration) declaration;
//        		//System.out.println(cppsimpledeclaration.getRawSignature());
//        		IASTDeclarator[] declarators = cppsimpledeclaration.getDeclarators();
//        		for (IASTDeclarator declarator : declarators) {
//        			//System.out.println(declarator.getClass());
//        			if (declarator instanceof CPPASTFunctionDeclarator) {
//	        			CPPASTFunctionDeclarator cppfunctiondeclarator = (CPPASTFunctionDeclarator) declarator;
//	        			System.out.println(cppfunctiondeclarator.getName());
//	        			IASTPointerOperator[] cpppointoperators = cppfunctiondeclarator.getPointerOperators();
//	        			for (IASTPointerOperator cpppointoperator : cpppointoperators) {
//	        				System.out.println(cpppointoperator.getRawSignature());
//	        			}
//        			}
//        			System.out.println("----");
//        		}        	        		
//        	}
//        	
//        	/*IASTDeclSpecifier declspecifier = ((CPPASTSimpleDeclaration) declaration).getDeclSpecifier();
//        	if (declspecifier instanceof CPPASTSimpleDeclSpecifier) {
//        		CPPASTSimpleDeclSpecifier cppsimpledeclspecifier = (CPPASTSimpleDeclSpecifier) declspecifier;
//        		System.out.println(cppsimpledeclspecifier.getType());        		
//        	}*/
//        }
        
        
        
        class datatypeParse {
        	boolean ptr;
        	int basicDatatype;
        	boolean signed;
        	boolean unsigned;
        	boolean long;
        	boolean short;
        	boolean longlong;
        	
        	public String getTypeName() {
        		String retName;
        		
        	}
        }
    }
}








//function type virtual, volatile, const, pointer type from *FunctionDeclarator
//object datatype signed, unsigned, long, short from *DeclSpecifier!






/*
// LUT for DeclSpecifiers types
t_auto 	10
t_bool 	6
t_char 	2
t_char16_t 	11
t_char32_t 	12
t_decltype 	9
t_double 	5
t_float 	4
t_int 	3
t_last 	5
t_typeof 	8
t_unspecified 	0
t_void 	1
t_wchar_t 	7
*/






// TODO: keep on adding to following map on encountering new datatypes!!
// custom enumeration for return types....these return types are supported so far!!

/* structure to hold type info
ptr (bool)=> '1' if type is of pointer type else '0'
basic datatype (int)=> 0 (unspecified), 1 (void), 2 (char), 3(int), 4(float), 5(double)
signed (bool)=> '1' if type is signed else '0'
unsigned (bool)=> '1' if type is unsigned else '0'
long (bool)=> '1' if type is long else '0'
short (bool)=> '1' if type is short else '0'
longlong (bool) => '1' if type is longlong else '0'
*/ 






